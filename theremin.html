<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Theremin mobilny — kalibracja X/Y/Z + ADSR (neon)</title>
<style>
  :root{
    --bg:#0e1117; --panel:#0a1420; --fg:#e6eef8; --mut:#9fb;
    --neon:#39ffc3; --neon2:#7ee1ff; --warn:#ffb86b; --err:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg);margin:0;padding:12px}
  h1{font-size:18px;margin:0 0 10px}
  .box{background:var(--panel);border:1px solid #22364f;border-radius:12px;padding:10px;margin:8px 0}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:6px 0}
  label{min-width:120px;font-size:13px}
  input[type=range],input[type=number],select{background:#142233;border:1px solid #2a3d55;color:var(--fg);border-radius:8px;padding:8px}
  .value{width:76px;text-align:center}
  .mut{color:var(--mut);font-size:12px}
  /* Neon buttons */
  .btn{position:relative; padding:10px 14px; border:1px solid #2a3d55; border-radius:10px; background:#101c2a; color:#dff; cursor:pointer; transition:transform .04s}
  .btn:active{transform:translateY(1px)}
  .btn.neon{box-shadow:0 0 0 rgba(0,0,0,0)}
  .btn.neon.on{
    border-color:#1a6; color:#eafff7;
    box-shadow:0 0 8px rgba(57,255,195,.6), 0 0 16px rgba(57,255,195,.35), inset 0 0 6px rgba(57,255,195,.2);
  }
  .btn.alt.on{
    border-color:#29a; color:#eaf7ff;
    box-shadow:0 0 8px rgba(126,225,255,.6), 0 0 16px rgba(126,225,255,.35), inset 0 0 6px rgba(126,225,255,.2);
  }
  .chip{display:inline-block;padding:2px 10px;border-radius:12px;border:1px solid #2a3d55;font-size:12px}
  .on{background:#0c281c;color:#93f7cc;border-color:#208d64}
  .off{background:#2a1410;color:#ffcdb1;border-color:#8d4b20}
  #wave{width:100%;height:170px;background:#06111a;border-radius:10px}
  #calibCanvas{width:100%;height:140px;background:#07111b;border-radius:10px}
  .progress{height:8px;background:#0b1826;border-radius:999px;overflow:hidden;border:1px solid #24364f}
  .progress>div{height:100%;width:0%;background:linear-gradient(90deg,var(--neon),var(--neon2));}
</style>
</head>
<body>
<h1>Theremin mobilny — kalibracja X/Y/Z + ADSR</h1>

<!-- STEROWANIE / PRZYCISKI -->
<div class="box">
  <div class="row">
    <button id="btnAudio" class="btn neon">Włącz audio</button>
    <button id="btnSensors" class="btn neon alt">Włącz czujniki</button>
    <button id="btnCal" class="btn">Kalibracja (neutral)</button>
    <button id="btnWizard" class="btn">Start kalibracji ruchu (X→Y→Z)</button>
    <button id="btnZero" class="btn">Wyzeruj pozycję</button>
    <button id="btnStop" class="btn">Stop</button>
    <button id="btnNote" class="btn neon alt">NOTE ON</button>
    <span id="gateChip" class="chip off">gate: OFF</span>
  </div>
  <div class="mut">
    Telefon przypięty do ręki jak „leży na stole” (ekran do góry).<br>
    • <b>X (lewo↔prawo)</b> → częstotliwość • <b>Y (góra↕dół)</b> → głośność • <b>Z</b> → wyjęcie/włożenie dłoni (mute poza warstwą).<br>
    Brak ruchu ⇒ pozycja (X,Y,Z) się utrzymuje. ADSR działa na NOTE ON/OFF.
  </div>
  <!-- SENSORY tuż pod opisem -->
  <div class="row mut" id="sensorStatus">
    <span id="dmAvail">DeviceMotion: —</span> · <span id="doAvail">DeviceOrientation: —</span> ·
    dx: <span id="dxVal" class="value">—</span> dy: <span id="dyVal" class="value">—</span> dz: <span id="dzVal" class="value">—</span>
  </div>
</div>

<!-- PARAMETRY RUCHU -->
<div class="box">
  <div class="row">
    <label>Zakres X (± m)</label><input id="rangeX" type="number" step="0.01" value="0.25" style="width:90px">
    <label>Zakres Y (m)</label><input id="rangeY" type="number" step="0.01" value="0.60" style="width:90px">
    <label>Warstwa Z (m)</label><input id="rangeZ" type="number" step="0.01" value="0.15" style="width:90px">
  </div>
  <div class="row">
    <label>Oktawy Y</label><input id="octaves" type="number" min="2" max="6" step="1" value="2" style="width:70px">
    <label>No-limit</label><input id="noLimit" type="checkbox">
    <label>Pitch base (Hz)</label><input id="pitchBase" type="number" value="220" step="1" style="width:80px">
  </div>
  <div class="row">
    <label>Smoothing</label><input id="smooth" type="range" min="0" max="0.98" step="0.01" value="0.90"><span id="smoothVal" class="value">0.90</span>
    <label>Deadzone a (m/s²)</label><input id="deadzone" type="range" min="0" max="0.25" step="0.005" value="0.03"><span id="deadVal" class="value">0.03</span>
    <label>Friction</label><input id="fric" type="range" min="0.90" max="0.999" step="0.001" value="0.992"><span id="fricVal" class="value">0.992</span>
    <label>Master gain</label><input id="gainMax" type="number" value="0.9" step="0.05" style="width:80px">
  </div>
  <div class="row">
    <label>Quantize</label><input id="quantize" type="checkbox">
    <select id="scale">
      <option value="none">Brak</option><option value="major">Dur</option><option value="minor">Mol nat.</option><option value="pent">Pentatonic</option>
    </select>
    <label>Oscylator</label>
    <select id="oscType">
      <option value="sine">sine</option><option value="triangle">triangle</option><option value="square">square</option><option value="sawtooth">sawtooth</option>
    </select>
  </div>
</div>

<!-- ADSR -->
<div class="box">
  <div style="font-weight:600;margin-bottom:4px">ADSR</div>
  <div class="row">
    <label>Attack (s)</label><input id="att" type="range" min="0" max="2" step="0.01" value="0.04"><span id="attVal" class="value">0.04</span>
    <label>Decay (s)</label><input id="dec" type="range" min="0" max="2" step="0.01" value="0.15"><span id="decVal" class="value">0.15</span>
    <label>Sustain</label><input id="sus" type="range" min="0" max="1" step="0.01" value="0.75"><span id="susVal" class="value">0.75</span>
    <label>Release (s)</label><input id="rel" type="range" min="0" max="3" step="0.01" value="0.30"><span id="relVal" class="value">0.30</span>
  </div>
  <div class="row">
    <label>Auto-gate</label><input id="autoGate" type="checkbox">
    <label>Gate on</label><input id="gateOnThr" type="number" step="0.01" value="0.25" style="width:80px">
    <label>Gate off</label><input id="gateOffThr" type="number" step="0.01" value="0.15" style="width:80px">
    <label>Debounce (ms)</label><input id="debounceMs" type="number" step="10" value="180" style="width:80px">
  </div>
</div>

<!-- FALA + KALIBRACJA -->
<div class="box">
  <canvas id="wave" width="960" height="170"></canvas>
</div>

<div class="box" id="wizardBox" style="display:none">
  <div class="row" style="width:100%;align-items:flex-start">
    <div style="flex:1;min-width:220px">
      <div style="font-weight:600;margin-bottom:6px">Kalibracja ruchu (3 etapy)</div>
      <div id="wizText" class="mut">Instrukcja pojawi się tutaj…</div>
      <div class="progress" style="margin-top:8px"><div id="wizProg"></div></div>
      <div class="row" style="margin-top:8px">
        <button id="wizStart" class="btn neon">Rozpocznij pomiar</button>
        <button id="wizCancel" class="btn">Zakończ</button>
      </div>
      <div class="mut" style="margin-top:6px">Wskazówka: ruch płynny, do skrajnych pozycji, w rytmie ~1 Hz. 5 pełnych powtórzeń w każdej osi.</div>
    </div>
    <div style="flex:1;min-width:220px;margin-left:10px">
      <canvas id="calibCanvas" width="480" height="140"></canvas>
      <div class="mut" style="margin-top:4px">Rysunek testu: X (↔) – machaj w lewo/prawo; Y (↕) – podnieś/opuść; Z – wysuń rękę do przodu i cofnij.</div>
    </div>
  </div>
</div>

<!-- ODCZYTY -->
<div class="box">
  <div class="row mut">
    <label>Odczyty</label>
    X (m): <span id="xRead" class="value">—</span>
    Y (m): <span id="yRead" class="value">—</span>
    Z (m): <span id="zRead" class="value">—</span>
    Pitch: <span id="pitchRead" class="value">—</span>
    Vol: <span id="volRead" class="value">—</span>
    Env: <span id="envRead" class="value">—</span>
    Wave: <span id="waveRead" class="value">—</span>
  </div>
</div>

<script>
(()=>{
// ========== POMOCNICZE ==========
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const lerp =(a,b,t)=>a+(b-a)*t;
function linMap(x,inA,inB,outA,outB){ if(inA===inB) return (outA+outB)/2; let t=(x-inA)/(inB-inA); t=clamp(t,0,1); return outA + t*(outB-outA); }

// ========== AUDIO ==========
let audio=null, osc=null, env=null, volGain=null, masterGain=null, analyser=null;
let running=false, gate=false;

function initAudio(){
  if(audio) return;
  audio=new (window.AudioContext||window.webkitAudioContext)();

  osc=audio.createOscillator();
  osc.type=document.getElementById('oscType').value||'sine';
  osc.frequency.value=440;

  env=audio.createGain(); env.gain.value=0;             // obwiednia
  volGain=audio.createGain(); volGain.gain.value=0;     // poziom z Y
  masterGain=audio.createGain(); masterGain.gain.value=parseFloat(gainMax.value);
  analyser=audio.createAnalyser(); analyser.fftSize=1024;

  osc.connect(env); env.connect(volGain); volGain.connect(masterGain);
  masterGain.connect(analyser); analyser.connect(audio.destination);
  osc.start();

  document.getElementById('oscType').addEventListener('change',()=>{ osc.type=document.getElementById('oscType').value; waveRead.textContent=osc.type; });
  gainMax.addEventListener('input',()=> masterGain.gain.value=parseFloat(gainMax.value));
}

function gateOn(){
  if(!audio) return;
  const now=audio.currentTime, A=+att.value, D=+dec.value, S=+sus.value;
  env.gain.cancelScheduledValues(now);
  env.gain.setValueAtTime(env.gain.value, now);
  env.gain.linearRampToValueAtTime(1.0, now + A);
  env.gain.linearRampToValueAtTime(S,   now + A + D);
}
function gateOff(){
  if(!audio) return;
  const now=audio.currentTime, R=+rel.value;
  env.gain.cancelScheduledValues(now);
  env.gain.setValueAtTime(env.gain.value, now);
  env.gain.linearRampToValueAtTime(0.0, now + R);
}
function setGate(on){
  gate=on;
  gateChip.textContent='gate: '+(on?'ON':'OFF');
  gateChip.classList.toggle('on',on); gateChip.classList.toggle('off',!on);
  btnNote.classList.toggle('on',on);
  btnNote.textContent = on ? 'NOTE OFF' : 'NOTE ON';
  if(on) gateOn(); else gateOff();
}

// ========== UI ELEMENTY ==========
const btnAudio = document.getElementById('btnAudio');
const btnSensors=document.getElementById('btnSensors');
const btnCal=document.getElementById('btnCal');
const btnWizard=document.getElementById('btnWizard');
const btnZero=document.getElementById('btnZero');
const btnStop=document.getElementById('btnStop');
const btnNote=document.getElementById('btnNote');
const gateChip=document.getElementById('gateChip');

const rangeX=document.getElementById('rangeX');
const rangeY=document.getElementById('rangeY');
const rangeZ=document.getElementById('rangeZ');
const octaves=document.getElementById('octaves');
const noLimit=document.getElementById('noLimit');
const pitchBase=document.getElementById('pitchBase');

const smooth=document.getElementById('smooth'), smoothVal=document.getElementById('smoothVal');
const deadzone=document.getElementById('deadzone'), deadVal=document.getElementById('deadVal');
const fric=document.getElementById('fric'), fricVal=document.getElementById('fricVal');
[smooth,deadzone,fric].forEach(el=>el.addEventListener('input',()=>{
  smoothVal.textContent=(+smooth.value).toFixed(2);
  deadVal.textContent=(+deadzone.value).toFixed(2);
  fricVal.textContent=(+fric.value).toFixed(3);
}));

const quantize=document.getElementById('quantize');
const scale=document.getElementById('scale');
const gainMax=document.getElementById('gainMax');

const dmAvail=document.getElementById('dmAvail');
const doAvail=document.getElementById('doAvail');
const dxVal=document.getElementById('dxVal');
const dyVal=document.getElementById('dyVal');
const dzVal=document.getElementById('dzVal');

const xRead=document.getElementById('xRead');
const yRead=document.getElementById('yRead');
const zRead=document.getElementById('zRead');
const pitchRead=document.getElementById('pitchRead');
const volRead=document.getElementById('volRead');
const envRead=document.getElementById('envRead');
const waveRead=document.getElementById('waveRead');

btnAudio.onclick = async ()=>{ initAudio(); if (audio.state==='suspended') await audio.resume(); running=true; btnAudio.classList.toggle('on',true); };
btnStop.onclick = ()=>{ running=false; setGate(false); };
btnNote.onclick = ()=> setGate(!gate);

// domyślnie auto-gate WYŁ. – stabilne testy
document.getElementById('autoGate').checked=false;

// ========== SENSORY ==========
dmAvail.textContent='DeviceMotion: ' + (typeof DeviceMotionEvent!=='undefined' ? 'OK' : 'brak');
doAvail.textContent='DeviceOrientation: ' + (typeof DeviceOrientationEvent!=='undefined' ? 'OK' : 'brak');

let ax=0, ay=0, az=0, baseAx=0, baseAy=0, baseAz=0;
async function enableSensors(){
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      const ok=await DeviceMotionEvent.requestPermission(); if(ok!=='granted') throw new Error('Brak zgody DeviceMotion');
    }
    if (typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      try{ await DeviceOrientationEvent.requestPermission(); }catch(_){}
    }
  }catch(_){}
  window.addEventListener('devicemotion', e=>{
    const src = e.acceleration || e.accelerationIncludingGravity || {x:0,y:0,z:0};
    ax = (src.x||0); ay=(src.y||0); az=(src.z||0);
    dxVal.textContent=ax.toFixed(3);
    dyVal.textContent=ay.toFixed(3);
    dzVal.textContent=az.toFixed(3);
  }, true);
  btnSensors.classList.toggle('on',true);
}
btnSensors.onclick=enableSensors;

btnCal.onclick=()=>{ baseAx=ax; baseAy=ay; baseAz=az; btnCal.classList.toggle('on',true); setTimeout(()=>btnCal.classList.remove('on'),400); };

// ========== MODEL POZYCJI (integracja kontrolowana + kalibracja) ==========
let posX=0, posY=0, posZ=0;       // m
let velX=0, velY=0, velZ=0;       // m/s
let lastT=null;

// czułości (będą korygowane przez „Wizard”)
let sensX=0.10, sensY=0.12, sensZ=0.12; // wpływ a*dt na dV skorygowane, bazowe
function resetPositions(){ posX=0; posY=0; posZ=0; velX=velY=velZ=0; }
btnZero.onclick=()=>{ resetPositions(); btnZero.classList.toggle('on',true); setTimeout(()=>btnZero.classList.remove('on'),300); };

function stepPosition(dt){
  const dz = +deadzone.value;
  let rx=ax-baseAx, ry=ay-baseAy, rz=az-baseAz;
  if (Math.abs(rx)<dz) rx=0;
  if (Math.abs(ry)<dz) ry=0;
  if (Math.abs(rz)<dz) rz=0;

  const F = +fric.value; // tarcie (0.90..0.999)
  velX = velX*F + rx*sensX*dt;
  velY = velY*F + ry*sensY*dt;
  velZ = velZ*F + rz*sensZ*dt;

  posX += velX*dt;
  posY += velY*dt;
  posZ += velZ*dt;

  const maxX = +rangeX.value, maxY=+rangeY.value, halfZ=+rangeZ.value*0.5;
  posX = clamp(posX, -maxX, maxX);
  posY = clamp(posY, 0, maxY);
  posZ = clamp(posZ, -halfZ*2, halfZ*2);
}

// ========== PITCH / VOLUME ==========
function freqFromY(y){
  const base = +pitchBase.value;
  const oct = +octaves.value;
  const maxY = +rangeY.value;
  let yNorm = y/maxY;
  if (noLimit.checked && y>maxY){
    yNorm = 1 + (y-maxY)/maxY; // powyżej – kolejne oktawy w tym samym tempie
  } else {
    yNorm = clamp(yNorm,0,1);
  }
  const octSpan = oct * yNorm;
  return base * Math.pow(2, octSpan);
}
function quantizeFreq(freq){
  if (!quantize.checked || scale.value==='none') return freq;
  const SCALES={major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10], pent:[0,2,4,7,9]};
  const sc=SCALES[scale.value]; if(!sc) return freq;
  const midi=69+12*Math.log2(freq/440);
  let best=Math.round(midi),bestD=1e9;
  for(let k=-24;k<=24;k++){
    const cand=Math.round(midi)+k, deg=((cand%12)+12)%12;
    if(sc.includes(deg)){ const d=Math.abs(cand-midi); if(d<bestD){bestD=d;best=cand;} }
  }
  return 440*Math.pow(2,(best-69)/12);
}

// ========== FALA / WIZUALIZACJA ==========
const wave = document.getElementById('wave'); const wctx=wave.getContext('2d');
function drawWave(){
  wctx.clearRect(0,0,wave.width,wave.height);
  wctx.fillStyle='#031017'; wctx.fillRect(0,0,wave.width,wave.height);
  // pitch bar
  const f=osc?osc.frequency.value:0;
  const fx=Math.min(wave.width, (f/ (220*Math.pow(2, +octaves.value+2))) * wave.width);
  wctx.fillStyle='#0f8'; wctx.fillRect(0,10,fx,18); wctx.fillStyle='#9fb'; wctx.fillText('Freq: '+Math.round(f)+' Hz',6,24);
  // vol bar
  const vg=volGain?volGain.gain.value:0;
  wctx.fillStyle='#f84'; wctx.fillRect(0,40, vg*wave.width,18); wctx.fillStyle='#ffd2b0'; wctx.fillText('Vol: '+vg.toFixed(2),6,54);
  // waveform
  if (analyser){
    let buf=new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buf);
    wctx.beginPath(); wctx.strokeStyle='#6cf'; wctx.lineWidth=1;
    const step=wave.width/buf.length;
    for(let i=0;i<buf.length;i++){
      const v=buf[i]/128.0, y=110+(v-1)*50;
      if(i===0) wctx.moveTo(0,y); else wctx.lineTo(i*step,y);
    }
    wctx.stroke();
  }
}

// ========== KALIBRACJA WIZARD ==========
const wizBox=document.getElementById('wizardBox');
const wizText=document.getElementById('wizText');
const wizProg=document.getElementById('wizProg');
const wizStart=document.getElementById('wizStart');
const wizCancel=document.getElementById('wizCancel');
const cCanvas=document.getElementById('calibCanvas'); const cctx=cCanvas.getContext('2d');

let wizStep=0, wizActive=false, wizCount=0, wizTargetRepeats=5;
let accHist=[], posStart={x:0,y:0,z:0};

function drawCalibHint(step, phase){
  cctx.clearRect(0,0,cCanvas.width,cCanvas.height);
  cctx.fillStyle='#0a0f16'; cctx.fillRect(0,0,cCanvas.width,cCanvas.height);
  cctx.strokeStyle='#2e5b84'; cctx.lineWidth=2;
  // osie
  const cx=cCanvas.width/2, cy=cCanvas.height/2;
  cctx.beginPath(); cctx.moveTo(20,cy); cctx.lineTo(cCanvas.width-20,cy); cctx.moveTo(cx,20); cctx.lineTo(cx,cCanvas.height-20); cctx.stroke();
  cctx.fillStyle='#9fb';
  if(step===1){ cctx.fillText('X: machaj w LEWO↔PRAWO', 14, 18); 
    // strzałki poziome
    cctx.fillStyle='rgba(126,225,255,.5)';
    cctx.fillRect(cx-150,cy-6,120,12); cctx.fillRect(cx+30,cy-6,120,12);
  } else if(step===2){ cctx.fillText('Y: PODNIEŚ i OPUŚĆ (~0.6 m)', 14, 18);
    cctx.fillStyle='rgba(57,255,195,.5)';
    cctx.fillRect(cx-6,cy-60,12,50); cctx.fillRect(cx-6,cy+10,12,50);
  } else if(step===3){ cctx.fillText('Z: WYSUŃ i COFNIJ (~0.15 m)', 14, 18);
    cctx.beginPath(); cctx.strokeStyle='rgba(255,184,107,.7)'; 
    cctx.arc(cx,cy,36,0,2*Math.PI); cctx.stroke();
    cctx.fillStyle='rgba(255,184,107,.2)'; cctx.beginPath(); cctx.arc(cx,cy,56,0,2*Math.PI); cctx.fill();
  }
}

function wizSetStep(s){
  wizStep=s; wizCount=0; accHist=[];
  let txt='';
  if(s===1) txt='Etap 1/3 — X: machaj dłonią w LEWO↔PRAWO, szeroko ~0.5 m. Zrób 5 pełnych przejść.';
  if(s===2) txt='Etap 2/3 — Y: podnieś rękę w GÓRĘ i OPUŚĆ, zakres ~0.6 m. 5 powtórzeń.';
  if(s===3) txt='Etap 3/3 — Z: wysuń dłoń do PRZODU i cofnij (~0.15 m „grubość” strefy). 5 powtórzeń.';
  if(s===0) txt='Gotowe. Możesz powtórzyć kalibrację lub zamknąć kreator.';
  wizText.textContent=txt;
  drawCalibHint(s,0);
  wizProg.style.width = (s===0?100: (s-1)*33.4) + '%';
}

btnWizard.onclick=()=>{
  wizActive = !wizActive;
  wizBox.style.display = wizActive ? 'block' : 'none';
  btnWizard.classList.toggle('on', wizActive);
  if(wizActive){ resetPositions(); wizSetStep(1); posStart={x:posX,y:posY,z:posZ}; } 
};

wizCancel.onclick=()=>{ wizActive=false; wizBox.style.display='none'; btnWizard.classList.remove('on'); };

wizStart.onclick=()=>{
  if(!wizActive) return;
  // Zliczamy „piki” pozycji w danej osi jako powtórzenia
  // co 30 ms próbkujemy pos i zapisujemy do accHist
  accHist=[];
};

// wykrywanie powtórzeń i kalibracja
let peakDir=0, lastAxisVal=0, rep=0, lastPeakT=0;
function detectRepeatsAndCalibrate(dt){
  if(!wizActive || wizStep===0) return;

  // wybierz oś i cel deklarowany
  let axis='x', target=+rangeX.value*2; // pełna rozpiętość
  if(wizStep===2){ axis='y'; target=+rangeY.value; }
  if(wizStep===3){ axis='z'; target=+rangeZ.value; }

  const val = (axis==='x'? posX : axis==='y'? posY : posZ);
  const now = performance.now();

  // wykryj lokalne odwrócenie kierunku jako „półokres”
  const deriv = val - lastAxisVal;
  const dir = deriv>0 ? 1 : deriv<0 ? -1 : 0;

  // zmiana kierunku = potencjalny szczyt
  if (dir!==0 && peakDir!==0 && dir!==peakDir && now-lastPeakT>120){
    rep++; lastPeakT=now;
    // co dwa piki ~ jeden pełny cykl
    if (rep%2===0) wizCount++;
    // zachowaj extremum
    accHist.push(val);
    // aktualizuj progress
    const stepBase = (wizStep-1)*33.4;
    const p = Math.min(33.4, (wizCount/wizTargetRepeats)*33.4);
    wizProg.style.width = (stepBase + p) + '%';
  }
  peakDir = dir; lastAxisVal = val;

  // po 5 pełnych przejściach kalibruj
  if (wizCount>=wizTargetRepeats){
    // z ekstrema policz amplitudę
    const minV = Math.min(...accHist, (axis==='x'?posStart.x:axis==='y'?posStart.y:posStart.z));
    const maxV = Math.max(...accHist, (axis==='x'?posStart.x:axis==='y'?posStart.y:posStart.z));
    const span = Math.abs(maxV - minV) || 1e-6;

    if (wizStep===1){
      const want = +rangeX.value*2; // lewo-prawo pełny
      const corr = want / span;
      sensX *= corr; // skoryguj czułość
    } else if (wizStep===2){
      const want = +rangeY.value;   // dół-góra
      const corr = want / span;
      sensY *= corr;
    } else if (wizStep===3){
      const want = +rangeZ.value;   // wysuń-cofnij
      const corr = want / span;
      sensZ *= corr;
    }

    // następny etap
    wizCount=0; accHist=[]; peakDir=0; lastAxisVal=0;
    if (wizStep<3) { wizSetStep(wizStep+1); posStart={x:posX,y:posY,z:posZ}; }
    else { wizSetStep(0); wizActive=false; wizBox.style.display='none'; btnWizard.classList.remove('on'); }
  }
}

// ========== PĘTLA ==========
let smoothPitch=null;
function loop(t){
  if (running){
    const now=t||performance.now();
    if (lastT==null) lastT=now;
    const dt=Math.min(0.05, Math.max(0.001,(now-lastT)/1000)); lastT=now;

    stepPosition(dt);
    detectRepeatsAndCalibrate(dt);

    // mapowanie: X→pitch (częstotliwość), Y→volume
    let freq = freqFromY(posY);
    freq = quantizeFreq(freq);
    const s=+smooth.value;
    if (smoothPitch==null) smoothPitch=freq;
    smoothPitch = lerp(smoothPitch, freq, 1-s);

    const halfZ = +rangeZ.value*0.5;
    const zActive = Math.abs(posZ) <= halfZ;

    if (osc)  osc.frequency.setTargetAtTime(smoothPitch, audio.currentTime, 0.02);
    if (volGain){
      // Y steruje głośnością liniowo po kalibracji zakresu (0..maxY)
      const vol = zActive ? clamp(posY/(+rangeY.value), 0, 1) : 0;
      volGain.gain.setTargetAtTime(vol, audio.currentTime, 0.03);
    }

    // odczyty
    xRead.textContent=posX.toFixed(3);
    yRead.textContent=posY.toFixed(3);
    zRead.textContent=posZ.toFixed(3);
    pitchRead.textContent=Math.round(smoothPitch);
    volRead.textContent=(volGain?volGain.gain.value:0).toFixed(2);
    envRead.textContent=(env?env.gain.value:0).toFixed(2);

    drawWave();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// resume audio po powrocie
document.addEventListener('visibilitychange', async ()=>{
  if (audio && audio.state==='suspended' && document.visibilityState==='visible'){
    try{ await audio.resume(); }catch(_){}
  }
});
})();
</script>
</body>
</html>
