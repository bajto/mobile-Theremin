<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Theremin mobilny — Kalibracja Z→Y→X + ADSR (neon)</title>
<style>
  :root{
    --bg:#0e1117; --panel:#0a1420; --fg:#e6eef8; --mut:#9fb;
    --neon:#39ffc3; --neon2:#7ee1ff;
  }
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg);margin:0;padding:12px}
  h1{font-size:18px;margin:0 0 10px}
  .box{background:var(--panel);border:1px solid #22364f;border-radius:12px;padding:10px;margin:8px 0}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:6px 0}
  label{min-width:120px;font-size:13px}
  input[type=range],input[type=number],select{background:#142233;border:1px solid #2a3d55;color:var(--fg);border-radius:8px;padding:8px}
  .value{width:80px;text-align:center}
  .mut{color:var(--mut);font-size:12px}

  /* Neon buttons (widoczny stan .on) */
  .btn{position:relative; padding:10px 14px; border:1px solid #2a3d55; border-radius:10px; background:#101c2a; color:#dff; cursor:pointer; transition:transform .04s, box-shadow .15s, border-color .15s}
  .btn:active{transform:translateY(1px)}
  .btn.neon.on{
    border-color:#1a6;
    box-shadow:0 0 8px rgba(57,255,195,.7), 0 0 16px rgba(57,255,195,.45), inset 0 0 8px rgba(57,255,195,.25);
    color:#eafff7;
  }
  .btn.neon.alt.on{
    border-color:#29a;
    box-shadow:0 0 8px rgba(126,225,255,.7), 0 0 16px rgba(126,225,255,.45), inset 0 0 8px rgba(126,225,255,.25);
    color:#f2fbff;
  }
  .chip{display:inline-block;padding:2px 10px;border-radius:12px;border:1px solid #2a3d55;font-size:12px}
  .chip.on{background:#0c281c;color:#93f7cc;border-color:#208d64}
  .chip.off{background:#2a1410;color:#ffcdb1;border-color:#8d4b20}

  #wave{width:100%;height:170px;background:#06111a;border-radius:10px}
  #calibCanvas{width:100%;height:140px;background:#07111b;border-radius:10px}

  .progress{height:8px;background:#0b1826;border-radius:999px;overflow:hidden;border:1px solid #24364f}
  .progress>div{height:100%;width:0%;background:linear-gradient(90deg,var(--neon),var(--neon2));}
</style>
</head>
<body>
<h1>Theremin mobilny — Z (mute) • Y (pitch) • X (volume)</h1>

<div class="box">
  <div class="row">
    <button id="btnAudio"   class="btn neon">Włącz audio</button>
    <button id="btnSensors" class="btn neon alt">Włącz czujniki</button>
    <button id="btnCal"     class="btn">Kalibracja (neutral)</button>
    <button id="btnWizard"  class="btn neon">Kreator kalibracji (Z→Y→X)</button>
    <button id="btnZero"    class="btn">Wyzeruj pozycję</button>
    <button id="btnStop"    class="btn">Stop</button>
    <button id="btnNote"    class="btn neon alt">NOTE ON</button>
    <span id="gateChip" class="chip off">gate: OFF</span>
  </div>
  <div class="mut">
    Telefon przypięty do dłoni jak „leży na stole” (ekran do góry).<br>
    • <b>Z</b>: włożenie/wyjęcie ręki ze strefy (mute poza strefą) ·
    • <b>Y (góra↕dół)</b>: <b>częstotliwość</b> (≥2 oktawy) ·
    • <b>X (lewo↔prawo)</b>: <b>głośność</b> (w strefie Z).<br>
    Brak ruchu ⇒ utrzymujemy ostatnie X/Y (dźwięk „stoi”).
  </div>
  <div class="row mut" id="sensorStatus">
    <span id="dmAvail">DeviceMotion: —</span> · <span id="doAvail">DeviceOrientation: —</span> ·
    dx: <span id="dxVal" class="value">—</span> dy: <span id="dyVal" class="value">—</span> dz: <span id="dzVal" class="value">—</span>
  </div>
</div>

<div class="box">
  <div class="row">
    <label>Zakres X (± m)</label><input id="rangeX" type="number" step="0.01" value="0.25" style="width:90px">
    <label>Zakres Y (m)</label><input id="rangeY" type="number" step="0.01" value="0.60" style="width:90px">
    <label>Warstwa Z (m)</label><input id="rangeZ" type="number" step="0.01" value="0.15" style="width:90px">
  </div>
  <div class="row">
    <label>Oktawy Y</label><input id="octaves" type="number" min="2" max="6" step="1" value="2" style="width:70px">
    <label>No-limit</label><input id="noLimit" type="checkbox">
    <label>Pitch base (Hz)</label><input id="pitchBase" type="number" value="220" step="1" style="width:80px">
  </div>
  <div class="row">
    <label>Smoothing</label><input id="smooth" type="range" min="0" max="0.98" step="0.01" value="0.92"><span id="smoothVal" class="value">0.92</span>
    <label>Deadzone a (m/s²)</label><input id="deadzone" type="range" min="0" max="0.25" step="0.005" value="0.03"><span id="deadVal" class="value">0.03</span>
    <label>Friction</label><input id="fric" type="range" min="0.90" max="0.999" step="0.001" value="0.993"><span id="fricVal" class="value">0.993</span>
    <label>Master gain</label><input id="gainMax" type="number" value="0.90" step="0.05" style="width:80px">
  </div>
  <div class="row">
    <label>Quantize</label><input id="quantize" type="checkbox">
    <select id="scale">
      <option value="none">Brak</option><option value="major">Dur</option><option value="minor">Mol nat.</option><option value="pent">Pentatonic</option>
    </select>
    <label>Oscylator</label>
    <select id="oscType">
      <option value="sine">sine</option><option value="triangle">triangle</option><option value="square">square</option><option value="sawtooth">sawtooth</option>
    </select>
  </div>
</div>

<div class="box">
  <div style="font-weight:600;margin-bottom:4px">ADSR</div>
  <div class="row">
    <label>Attack (s)</label><input id="att" type="range" min="0" max="2" step="0.01" value="0.05"><span id="attVal" class="value">0.05</span>
    <label>Decay (s)</label><input id="dec" type="range" min="0" max="2" step="0.01" value="0.15"><span id="decVal" class="value">0.15</span>
    <label>Sustain</label><input id="sus" type="range" min="0" max="1" step="0.01" value="0.75"><span id="susVal" class="value">0.75</span>
    <label>Release (s)</label><input id="rel" type="range" min="0" max="3" step="0.01" value="0.30"><span id="relVal" class="value">0.30</span>
  </div>
  <div class="row">
    <label>Auto-gate</label><input id="autoGate" type="checkbox">
    <label>Gate on</label><input id="gateOnThr" type="number" step="0.01" value="0.25" style="width:80px">
    <label>Gate off</label><input id="gateOffThr" type="number" step="0.01" value="0.15" style="width:80px">
    <label>Debounce (ms)</label><input id="debounceMs" type="number" step="10" value="180" style="width:80px">
  </div>
</div>

<div class="box">
  <canvas id="wave" width="960" height="170"></canvas>
</div>

<!-- KREATOR: Z → Y → X -->
<div class="box" id="wizardBox" style="display:none">
  <div class="row" style="width:100%;align-items:flex-start">
    <div style="flex:1;min-width:240px">
      <div style="font-weight:600;margin-bottom:6px">Kreator kalibracji</div>
      <div id="wizText" class="mut">Instrukcja pojawi się tutaj…</div>
      <div class="progress" style="margin-top:8px"><div id="wizProg"></div></div>
      <div class="row" id="wizBtns" style="margin-top:8px"></div>
      <div class="mut" style="margin-top:6px">Kroki: 1) <b>Z</b> (włóż→potwierdź, wyjmij→potwierdź) · 2) <b>Y</b> (5x góra/dół) · 3) <b>X</b> (5x lewo/prawo <i>w strefie Z</i>).</div>
    </div>
    <div style="flex:1;min-width:240px;margin-left:10px">
      <canvas id="calibCanvas" width="480" height="140"></canvas>
      <div class="mut" style="margin-top:4px">Rysunek testu: Z – wsuwaj/wyjmuj; Y – podnoś/opuszczaj; X – przesuwaj w poziomie (w strefie Z).</div>
    </div>
  </div>
</div>

<div class="box">
  <div class="row mut">
    <label>Odczyty</label>
    X (m): <span id="xRead" class="value">—</span>
    Y (m): <span id="yRead" class="value">—</span>
    Z (m): <span id="zRead" class="value">—</span>
    Pitch: <span id="pitchRead" class="value">—</span>
    Vol: <span id="volRead" class="value">—</span>
    Env: <span id="envRead" class="value">—</span>
    Wave: <span id="waveRead" class="value">—</span>
  </div>
</div>

<script>
(()=>{
// ---------- utils ----------
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const lerp =(a,b,t)=>a+(b-a)*t;

// ---------- audio ----------
let audio=null, osc=null, env=null, volGain=null, masterGain=null, analyser=null;
let running=false, gate=false;

function initAudio(){
  if(audio) return;
  audio=new (window.AudioContext||window.webkitAudioContext)();
  osc=audio.createOscillator();
  osc.type=oscType.value; osc.frequency.value=440;
  env=audio.createGain(); env.gain.value=0;
  volGain=audio.createGain(); volGain.gain.value=0;
  masterGain=audio.createGain(); masterGain.gain.value=parseFloat(gainMax.value);
  analyser=audio.createAnalyser(); analyser.fftSize=1024;
  osc.connect(env); env.connect(volGain); volGain.connect(masterGain);
  masterGain.connect(analyser); analyser.connect(audio.destination);
  osc.start();
  oscType.addEventListener('change',()=>{ osc.type=oscType.value; waveRead.textContent=osc.type; });
  gainMax.addEventListener('input',()=> masterGain.gain.value=parseFloat(gainMax.value));
}

function gateOn(){
  if(!audio) return;
  const now=audio.currentTime, A=+att.value, D=+dec.value, S=+sus.value;
  env.gain.cancelScheduledValues(now);
  env.gain.setValueAtTime(env.gain.value, now);
  env.gain.linearRampToValueAtTime(1.0, now+A);
  env.gain.linearRampToValueAtTime(S,   now+A+D);
}
function gateOff(){
  if(!audio) return;
  const now=audio.currentTime, R=+rel.value;
  env.gain.cancelScheduledValues(now);
  env.gain.setValueAtTime(env.gain.value, now);
  env.gain.linearRampToValueAtTime(0.0, now+R);
}
function setGate(on){
  gate=on;
  gateChip.textContent='gate: '+(on?'ON':'OFF');
  gateChip.classList.toggle('on',on); gateChip.classList.toggle('off',!on);
  btnNote.classList.toggle('on',on);
  btnNote.textContent = on ? 'NOTE OFF' : 'NOTE ON';
  if(on) gateOn(); else gateOff();
}

// ---------- DOM ----------
const btnAudio = document.getElementById('btnAudio');
const btnSensors=document.getElementById('btnSensors');
const btnCal=document.getElementById('btnCal');
const btnWizard=document.getElementById('btnWizard');
const btnZero=document.getElementById('btnZero');
const btnStop=document.getElementById('btnStop');
const btnNote=document.getElementById('btnNote');
const gateChip=document.getElementById('gateChip');

const rangeX=document.getElementById('rangeX');
const rangeY=document.getElementById('rangeY');
const rangeZ=document.getElementById('rangeZ');
const octaves=document.getElementById('octaves');
const noLimit=document.getElementById('noLimit');
const pitchBase=document.getElementById('pitchBase');

const smooth=document.getElementById('smooth'), smoothVal=document.getElementById('smoothVal');
const deadzone=document.getElementById('deadzone'), deadVal=document.getElementById('deadVal');
const fric=document.getElementById('fric'), fricVal=document.getElementById('fricVal');

const quantize=document.getElementById('quantize'), scale=document.getElementById('scale');
const gainMax=document.getElementById('gainMax'), oscType=document.getElementById('oscType');

const dmAvail=document.getElementById('dmAvail');
const doAvail=document.getElementById('doAvail');
const dxVal=document.getElementById('dxVal'), dyVal=document.getElementById('dyVal'), dzVal=document.getElementById('dzVal');

const xRead=document.getElementById('xRead'), yRead=document.getElementById('yRead'), zRead=document.getElementById('zRead');
const pitchRead=document.getElementById('pitchRead'), volRead=document.getElementById('volRead'), envRead=document.getElementById('envRead'), waveRead=document.getElementById('waveRead');

const wave=document.getElementById('wave'); const wctx=wave.getContext('2d');

btnAudio.onclick = async ()=>{ initAudio(); if (audio.state==='suspended') await audio.resume(); running=true; btnAudio.classList.add('on'); };
btnStop.onclick = ()=>{ running=false; setGate(false); };
btnNote.onclick = ()=> setGate(!gate);
btnZero.onclick = ()=>{ posX=posY=posZ=velX=velY=velZ=0; btnZero.classList.add('on'); setTimeout(()=>btnZero.classList.remove('on'),220); };

smooth.addEventListener('input',()=> smoothVal.textContent=(+smooth.value).toFixed(2));
deadzone.addEventListener('input',()=> deadVal.textContent=(+deadzone.value).toFixed(2));
fric.addEventListener('input',()=> fricVal.textContent=(+fric.value).toFixed(3));

// ---------- sensors ----------
dmAvail.textContent='DeviceMotion: ' + (typeof DeviceMotionEvent!=='undefined' ? 'OK' : 'brak');
doAvail.textContent='DeviceOrientation: ' + (typeof DeviceOrientationEvent!=='undefined' ? 'OK' : 'brak');

let ax=0, ay=0, az=0, baseAx=0, baseAy=0, baseAz=0;
btnSensors.onclick = async ()=>{
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      const ok=await DeviceMotionEvent.requestPermission(); if(ok!=='granted') throw new Error('Brak zgody DeviceMotion');
    }
    if (typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      try{ await DeviceOrientationEvent.requestPermission(); }catch(_){}
    }
  }catch(_){}
  window.addEventListener('devicemotion', e=>{
    const src=e.acceleration || e.accelerationIncludingGravity || {x:0,y:0,z:0};
    ax=src.x||0; ay=src.y||0; az=src.z||0;
    dxVal.textContent=ax.toFixed(3); dyVal.textContent=ay.toFixed(3); dzVal.textContent=az.toFixed(3);
  }, true);
  btnSensors.classList.add('on');
};
btnCal.onclick = ()=>{ baseAx=ax; baseAy=ay; baseAz=az; btnCal.classList.add('on'); setTimeout(()=>btnCal.classList.remove('on'),220); };

// ---------- position model ----------
let posX=0,posY=0,posZ=0, velX=0,velY=0,velZ=0, lastT=null;
let sensX=0.10, sensY=0.12, sensZ=0.12; // modyfikowane przez kreator

function stepPosition(dt){
  const dz=+deadzone.value;
  let rx=ax-baseAx, ry=ay-baseAy, rz=az-baseAz;
  if(Math.abs(rx)<dz) rx=0;
  if(Math.abs(ry)<dz) ry=0;
  if(Math.abs(rz)<dz) rz=0;
  const F=+fric.value;
  velX = velX*F + rx*sensX*dt;
  velY = velY*F + ry*sensY*dt;
  velZ = velZ*F + rz*sensZ*dt;
  posX += velX*dt; posY += velY*dt; posZ += velZ*dt;

  const maxX=+rangeX.value, maxY=+rangeY.value, hz=+rangeZ.value*0.5;
  posX=clamp(posX,-maxX,maxX);
  posY=clamp(posY,0,maxY);
  posZ=clamp(posZ,-hz*2,hz*2);
}

// ---------- pitch/volume ----------
function freqFromY(y){
  const base=+pitchBase.value, oct=+octaves.value, maxY=+rangeY.value;
  let yNorm = y/maxY;
  if(noLimit.checked && y>maxY) yNorm = 1 + (y-maxY)/maxY;
  else yNorm = clamp(yNorm,0,1);
  const octSpan = oct*yNorm;
  return base * Math.pow(2, octSpan);
}
function quantizeFreq(freq){
  if(!quantize.checked || scale.value==='none') return freq;
  const S={major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10], pent:[0,2,4,7,9]};
  const sc=S[scale.value]; if(!sc) return freq;
  const midi=69+12*Math.log2(freq/440);
  let best=Math.round(midi),bestD=1e9;
  for(let k=-24;k<=24;k++){
    const cand=Math.round(midi)+k, deg=((cand%12)+12)%12;
    if(sc.includes(deg)){ const d=Math.abs(cand-midi); if(d<bestD){bestD=d;best=cand;} }
  }
  return 440*Math.pow(2,(best-69)/12);
}

// ---------- wizard Z→Y→X ----------
const wizardBox=document.getElementById('wizardBox');
const wizText=document.getElementById('wizText');
const wizProg=document.getElementById('wizProg');
const wizBtns=document.getElementById('wizBtns');
const cCanvas=document.getElementById('calibCanvas'); const cctx=cCanvas.getContext('2d');

let wizStep=0, wizActive=false, reps=0, peakDir=0, lastVal=0, lastPeakT=0;
function drawHint(){
  cctx.clearRect(0,0,cCanvas.width,cCanvas.height);
  cctx.fillStyle='#0a0f16'; cctx.fillRect(0,0,cCanvas.width,cCanvas.height);
  cctx.strokeStyle='#2e5b84'; cctx.lineWidth=2;
  const cx=cCanvas.width/2, cy=cCanvas.height/2;
  cctx.beginPath(); cctx.moveTo(20,cy); cctx.lineTo(cCanvas.width-20,cy); cctx.moveTo(cx,20); cctx.lineTo(cx,cCanvas.height-20); cctx.stroke();
  cctx.fillStyle='#9fb';
  if(wizStep===1){ cctx.fillText('Krok 1: Z — włóż (potwierdź), wyjmij (potwierdź)',14,18); cctx.beginPath(); cctx.arc(cx,cy,36,0,2*Math.PI); cctx.stroke(); }
  if(wizStep===2){ cctx.fillText('Krok 2: Y — podnieś/opuść 5x',14,18); cctx.fillRect(cx-6,cy-60,12,50); cctx.fillRect(cx-6,cy+10,12,50); }
  if(wizStep===3){ cctx.fillText('Krok 3: X — lewo/prawo 5x (w strefie Z)',14,18); cctx.fillRect(cx-150,cy-6,120,12); cctx.fillRect(cx+30,cy-6,120,12); }
}

function setWizStep(s){
  wizStep=s; reps=0; peakDir=0; lastVal=0; lastPeakT=0;
  wizProg.style.width = (s===0?100:(s-1)*33.4)+'%';
  drawHint();
  wizBtns.innerHTML='';
  if(s===1){
    wizText.textContent='Krok 1/3 — Z: włóż rękę do strefy (blisko), naciśnij „Potwierdź: w strefie”. Następnie wyjmij rękę ze strefy i naciśnij „Potwierdź: poza strefą”.';
    const b1=document.createElement('button'); b1.className='btn neon on'; b1.textContent='Potwierdź: w strefie';
    const b2=document.createElement('button'); b2.className='btn neon on'; b2.textContent='Potwierdź: poza strefą';
    b1.onclick=()=>{ zInSample = posZ; b1.disabled=true; };
    b2.onclick=()=>{ zOutSample = posZ; // policz środek i połowę grubości
      const span = Math.abs(zOutSample - zInSample) || 1e-6;
      const want = +rangeZ.value;
      const corr = want / span;  // skoryguj czułość Z
      sensZ *= corr;
      zCenter = (zOutSample + zInSample)/2;
      b2.disabled=true; setWizStep(2);
    };
    wizBtns.appendChild(b1); wizBtns.appendChild(b2);
  } else if(s===2){
    wizText.textContent='Krok 2/3 — Y: wykonaj 5 płynnych podniesień/opuszczeń (~0.6 m pełnego zakresu).';
    const b=document.createElement('button'); b.className='btn neon on'; b.textContent='Zacznij Y (5x)'; b.onclick=()=>{ startRepAxis='y'; reps=0; }; wizBtns.appendChild(b);
  } else if(s===3){
    wizText.textContent='Krok 3/3 — X: włóż rękę do strefy Z i wykonaj 5 ruchów lewo/prawo (~0.5 m pełnego zakresu).';
    const b=document.createElement('button'); b.className='btn neon on'; b.textContent='Zacznij X (5x)'; b.onclick=()=>{ startRepAxis='x'; reps=0; }; wizBtns.appendChild(b);
  } else {
    wizText.textContent='Kalibracja zakończona. Możesz zamknąć kreator.';
    const b=document.createElement('button'); b.className='btn'; b.textContent='Zamknij kreator'; b.onclick=()=>{ wizardBox.style.display='none'; btnWizard.classList.remove('on'); wizActive=false; }; wizBtns.appendChild(b);
  }
}

let zCenter=0, zInSample=0, zOutSample=0, startRepAxis=null;

btnWizard.onclick=()=>{
  wizActive=!wizActive;
  btnWizard.classList.toggle('on',wizActive);
  wizardBox.style.display = wizActive ? 'block' : 'none';
  if(wizActive){ setWizStep(1); }
};

function detectRepeats(dt){
  if(!wizActive || !startRepAxis) return;
  // W kroku X wymagamy by ręka była w strefie Z
  const zActive = Math.abs(posZ - zCenter) <= (+rangeZ.value * 0.5);
  if(startRepAxis==='x' && !zActive) return;

  const val = (startRepAxis==='y') ? posY : posX;
  const deriv = val - lastVal;
  const dir = deriv>0 ? 1 : deriv<0 ? -1 : 0;
  const now = performance.now();
  if (dir!==0 && peakDir!==0 && dir!==peakDir && now-lastPeakT>120){
    // co 2 piki = 1 cykl
    reps += 0.5;
    lastPeakT=now;
    wizProg.style.width = ( (wizStep-1)*33.4 + Math.min(33.4, (reps/5)*33.4) ) + '%';
  }
  peakDir=dir; lastVal=val;

  if (reps>=5){
    // skalibruj czułość dla osi
    const want = (startRepAxis==='y') ? (+rangeY.value) : (+rangeX.value*2);
    // oszacuj realny span z ostatnich ~2s
    // (prosto: użyj min/max pozycji z tego okresu)
    if(!window._spanHist) window._spanHist=[];
    window._spanHist.push(val);
    if(window._spanHist.length>100) window._spanHist.shift();
    const minV=Math.min(...window._spanHist), maxV=Math.max(...window._spanHist);
    const span=Math.max(1e-6, Math.abs(maxV-minV));
    const corr = want / span;
    if(startRepAxis==='y') sensY *= corr; else sensX *= corr;

    window._spanHist=[];
    startRepAxis=null; reps=0;
    if (wizStep===2) setWizStep(3);
    else setWizStep(0);
  }
}

// ---------- drawing ----------
function drawWave(){
  wctx.clearRect(0,0,wave.width,wave.height);
  wctx.fillStyle='#031017'; wctx.fillRect(0,0,wave.width,wave.height);

  // pitch bar
  const f=osc?osc.frequency.value:0;
  const fx=Math.min(wave.width, (f/(220*Math.pow(2, +octaves.value+2))) * wave.width);
  wctx.fillStyle='#0f8'; wctx.fillRect(0,10,fx,18); wctx.fillStyle='#9fb'; wctx.fillText('Freq: '+Math.round(f)+' Hz',6,24);

  // vol bar
  const vg=volGain?volGain.gain.value:0;
  wctx.fillStyle='#f84'; wctx.fillRect(0,40, vg*wave.width,18); wctx.fillStyle='#ffd2b0'; wctx.fillText('Vol: '+vg.toFixed(2),6,54);

  // waveform
  if(analyser){
    const buf=new Uint8Array(analyser.fftSize); analyser.getByteTimeDomainData(buf);
    wctx.beginPath(); wctx.strokeStyle='#6cf'; wctx.lineWidth=1;
    const step=wave.width/buf.length;
    for(let i=0;i<buf.length;i++){
      const v=buf[i]/128.0, y=110+(v-1)*50;
      if(i===0) wctx.moveTo(0,y); else wctx.lineTo(i*step,y);
    }
    wctx.stroke();
  }
  // Z-strefa (opis)
  wctx.fillStyle='rgba(255,255,255,.08)';
  wctx.fillRect(0,wave.height-20,wave.width,4);
  wctx.fillStyle='#9fb';
  wctx.fillText('Z strefa ±'+(+rangeZ.value*0.5).toFixed(2)+' m (poza → mute)',6,wave.height-8);
}

// ---------- loop ----------
let smoothPitch=null;
function loop(t){
  if (running){
    const now=t||performance.now();
    if (lastT==null) lastT=now;
    const dt=Math.min(0.05, Math.max(0.001,(now-lastT)/1000)); lastT=now;

    stepPosition(dt);
    detectRepeats(dt);

    // Y → pitch (log), X → volume (lin), Z → mute
    let freq=freqFromY(posY);
    freq = quantizeFreq(freq);
    const s=+smooth.value;
    if (smoothPitch==null) smoothPitch=freq;
    smoothPitch = smoothPitch*s + freq*(1-s);

    const zHalf=+rangeZ.value*0.5;
    const zActive = Math.abs(posZ - zCenter) <= zHalf;

    if (osc)  osc.frequency.setTargetAtTime(smoothPitch, audio.currentTime, 0.02);
    if (volGain){
      const vol = zActive ? clamp( (posX/(+rangeX.value)*0.5 + 0.5), 0, 1) : 0;
      volGain.gain.setTargetAtTime(vol, audio.currentTime, 0.03);
    }
    // jeśli Z wyłącza – zamknij gate; jeśli wraca – otwórz (tylko gdy Auto-gate aktywny)
    if (document.getElementById('autoGate').checked){
      if (!zActive && gate) setGate(false);
      if (zActive && !gate) setGate(true);
    }

    // odczyty
    xRead.textContent=posX.toFixed(3);
    yRead.textContent=posY.toFixed(3);
    zRead.textContent=posZ.toFixed(3);
    pitchRead.textContent=Math.round(smoothPitch);
    volRead.textContent=(volGain?volGain.gain.value:0).toFixed(2);
    envRead.textContent=(env?env.gain.value:0).toFixed(2);

    drawWave();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// resume audio
document.addEventListener('visibilitychange', async ()=>{
  if (audio && audio.state==='suspended' && document.visibilityState==='visible'){
    try{ await audio.resume(); }catch(_){}
  }
});
})();
</script>
</body>
</html>
